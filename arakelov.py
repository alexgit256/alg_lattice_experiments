

# This file was *autogenerated* from the file arakelov.sage
from sage.all_cmdline import *   # import sage library

_sage_const_48 = Integer(48); _sage_const_10 = Integer(10); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_2p = RealNumber('2.'); _sage_const_1p = RealNumber('1.'); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_3 = Integer(3); _sage_const_12 = Integer(12); _sage_const_80 = Integer(80); _sage_const_7 = Integer(7); _sage_const_11 = Integer(11); _sage_const_8 = Integer(8); _sage_const_31 = Integer(31); _sage_const_0p2 = RealNumber('0.2'); _sage_const_0p01 = RealNumber('0.01')
import sys, os, time
import sage.misc.randstate as randstate

Prec = _sage_const_48 
max_counter=_sage_const_10 
RealNumber = RealField( Prec )
ComplexNumber = ComplexField( Prec )
RR = RealField( Prec )
CC = ComplexField( Prec )

def butterfly(v_,s):
    #butterfly step of fft

    v=[t for t in v_]
    n = len(v_)
    if n>_sage_const_1 :
        vp = v_[_sage_const_0 :n:_sage_const_2 ]
        vi = v_[_sage_const_1 :n:_sage_const_2 ]
        vi = butterfly(vi,s)
        vp = butterfly(vp,s)

        zeta=(exp(-_sage_const_2p *I*pi/n*s)).n(Prec)
        mu=_sage_const_1 
        for i in range(n/_sage_const_2 ):
            t=mu*vi[i]
            v_[i+n/_sage_const_2 ]=vp[i]-t
            v_[i]=vp[i]+t
            mu*=zeta
    return v_ if isinstance(v,list) else [v_] #force to return list

def ifft(v,real_value=True):
    #subroutine for inverse minkowsky

    d=len(v)
    z=(e**(-_sage_const_1p *pi*I/d)).n(Prec)
    z=CC(z)

    v = list(v)
    v=butterfly(v,_sage_const_1 )

    for i in range(len(v)):
        v[i]*=(z**i)

    v = [CC(t)/d for t in v] if not real_value else [t[_sage_const_0 ]/d for t in v]

    a_= [QQ(RR(t)) for t in v]

    return a_

def inv_minkowski_embedding(s):
    #we have real coefficients so only half the embeddings are enough (truncated=True)
    f = _sage_const_4 *len(s)
    K = CyclotomicField(f, names=('z',)); (z,) = K._first_ngens(1)
    tmp = list( s[:] ) + [_sage_const_0 ]*len(s)
    for i in range(len(s)-_sage_const_1 ,-_sage_const_1 ,-_sage_const_1 ):
        tmp[len(tmp)-_sage_const_1 -i] = s[i].conjugate()

    return K( ifft(tmp) )

def log_embedding(a,truncated=True):
    ac = minkowski_embedding(a,truncated)
    return _sage_const_2 *vector(RealField(Prec), [ln(abs(t).n(Prec)) for t in ac])

def inv_log_embedding(s):
    tmp = [e.n()**(t/_sage_const_2 ) for t in s]
    a = inv_minkowski_embedding(tmp)
    return a

def roundoff(a):
  OK = a.parent().fraction_field().ring_of_integers()
  return OK( [round(t) for t in a] )

def gen_fact_base(B=_sage_const_5 ):
    P = []
    p=_sage_const_1 
    while p< B:
        p = next_prime(p)
        P.append(p)
    return P

def nearest_P_smooth_number(N,P=None):
    p_max = None
    if P is None:
        p_max = max( _sage_const_3 , round( log(log(N,_sage_const_2 ),_sage_const_2 ) ) )
        P = gen_fact_base( p_max )
    if abs(ln(N)) < _sage_const_10 :
        scale = round( _sage_const_10  + _sage_const_2 *log(N,_sage_const_2 ) )
    else: scale = round( sqrt(len(P))*log(N,_sage_const_2 )**_sage_const_4  )
    n = len(P)
    M = [None]*(n+_sage_const_1 )
    logn = log(N,_sage_const_2 )
    for i in range(n):
        M[i] = [_sage_const_0 ]*i + [_sage_const_1 ] + [_sage_const_0 ]*(n-i-_sage_const_1 ) + [round( log(P[i],_sage_const_2 ) * scale )]
    M[n] = [_sage_const_0 ]*n + [round(logn * scale)]
    M = matrix(ZZ,M)
    #print(M)
    M = M.LLL()

    min_diff = Infinity
    found_v = []
    found_C = _sage_const_0 
    for v in M:
        C = ( prod(P[i]**v[i] for i in range(len(P))) )
        if C < _sage_const_1 :  #if algorithm returned inverse of ~N, make it 1/C
            C = _sage_const_1 /C
        diff = abs(ln(C)-ln(N))
        if diff < min_diff:
            min_diff = diff
            found_v = v
            found_C = C
    if abs(ln(found_C)-ln(N))>ln( sqrt(_sage_const_2 ).n() ):  #if it didn't work, we found garbage and give up
        return _sage_const_2 **( round(log(N,_sage_const_2 )) )
    return(found_C)

def gen_smooth_nearly_unit_ideal( K, n=_sage_const_12 , B=_sage_const_10 **_sage_const_10  ):
    scale=_sage_const_4 *log(B,_sage_const_2 )**_sage_const_2 

    P = [ rand_p_ideal( K, B) for i in range(n) ]
    Norms = [ ln(p.norm()) for p in P ]

    B = matrix(ZZ, [
        i*[_sage_const_0 ]+[_sage_const_1 ]+(n-i-_sage_const_1 )*[_sage_const_0 ]+[round(Norms[i]*scale)] for i in range(n)
    ])

    B = B.LLL()

    min_norm = Infinity
    min_i = None
    for v in B:
        if abs(v[-_sage_const_1 ])<min_norm:
            min_norm = abs(v[-_sage_const_1 ])
            min_v = v
    return(prod( P[i]**min_v[i] for i in range(n) ))

# - - - The funtions - - -

rounding_factor = _sage_const_2 **_sage_const_80 
log_rounding_factor = round( log(rounding_factor,_sage_const_2 ) )
factor_base = [_sage_const_2 , _sage_const_3 , _sage_const_5 , _sage_const_7 , _sage_const_11 ]

def gen_gauss_sum_to_zero(n,s):
    #Samples vector from gauss distridution with deviation s and makes the sum of its coefficients equal to zero.
    D = RealDistribution('gaussian', s)
    l = [ CC(D.get_random_element(),D.get_random_element()) for i in range(n) ]
    l[-_sage_const_1 ] -= sum(l)
    return(l)

def steps_num(d):
    """
    Given the degree of field, returns number of Arakelov jump steps required for the randomization.
    See Corollary 3.5 in https://eprint.iacr.org/2020/297.pdf
    """
    N = d/( _sage_const_2 *log(d,_sage_const_2 ) ) * ( _sage_const_8 *log(log(d,_sage_const_2 ),_sage_const_2 )/log(d,_sage_const_2 ) + _sage_const_1 /_sage_const_2  )
    return ceil(N)

def bound_on_B(d):
    """
    Given the degree of field, returns ~ bound on the prime ideals required for the randomization.
    We omit wavy-O notation in the Corollary 3.5 in https://eprint.iacr.org/2020/297.pdf
    """
    return ceil(d**(_sage_const_2 +_sage_const_2 *log(d,_sage_const_2 )))


def rand_p_ideal(K, B):
    #returns ring of integer's prime ideal of norm < B
    d = K.degree()
    assert B>=_sage_const_3 , f"Wrong B!"

    p = _sage_const_4 
    while True:
        randstate.set_random_seed((hash(p+time.perf_counter()))%_sage_const_2 **_sage_const_31 )  #rerandomize
        p = ZZ( randrange(_sage_const_2 ,B) )
        while not ( p.is_prime() ):
            p = ZZ( randrange(_sage_const_2 ,B) )    #sample prime p
        F = Ideal( K(p) ).factor()      #factor (p) into product of prime ideals
        I_norm = Infinity
        counter=_sage_const_0 
        while I_norm >B and counter<=max_counter:   #while among factors the ideal of norm < B not found (and num of steps is not too high)
            I = F[ randrange(len(F)) ][_sage_const_0 ]   #choose new one
            I_norm = norm( I )
            counter+=_sage_const_1 
        if I_norm<B:
            break
    return(I)

def arakelov_crawl(II, s, smooth_unit=False):
    #II is ideal
    if s==_sage_const_0 :
        return II

    d = II.ring().degree()
    v = vector(gen_gauss_sum_to_zero(d//_sage_const_4 ,s))
    assert abs( sum([t for t in v]) ) < _sage_const_10 **-_sage_const_3 , f"Not a unit after log-embedding!"

    if smooth_unit:
        U = gen_smooth_nearly_unit_ideal( II.ring() )
        assert abs( ln( abs(norm(U)) ) )<_sage_const_0p2 , f"Not a unit! {abs( ln( abs(norm(U)) ) ).n()}"
        return U*II
    else:
        u = ( inv_log_embedding(v) )
        u_stash = u

        denom = u.denominator()
        u = roundoff( rounding_factor*u )/rounding_factor

        assert( abs( ln(norm(u_stash))-ln(norm(u)) ) < _sage_const_0p01  ), f"u is not a unit! Diff: { abs(ln(norm(u_stash))-ln(norm(u))).n()}"

    #u = roundoff(rounding_factor*u)/rounding_factor
    assert abs(ln(u.norm())) < _sage_const_0p2 , f"arakelov_crawl - precision issues: {abs(ln(u.norm())).n()}"

    return( II*u )

def arakelov_jump(II, B):
    p = rand_p_ideal( II.ring(), B )
    II = p*II

    return II

def arakelov_rand_walk(II, B, s, N, normalize=True, smooth_unit=False):
    """
    pass all bounds to the function, no need to recompute the d
    """
    norm_stash = II.norm()
    for i in range(N):
        II =  arakelov_jump( II, B )
    II = arakelov_crawl( II, s, smooth_unit ) #we do crawl only once
    if normalize:
        d = II.ring().degree()
        scale = ( norm(II) / norm_stash )**(_sage_const_1 /d)
        II = II  / nearest_P_smooth_number( scale, factor_base )
    return( II )

