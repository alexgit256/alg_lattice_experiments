
from fpylll import BKZ as BKZ_FPYLLL
from fpylll import LLL as LLL_FPYLLL
from fpylll import GSO, IntegerMatrix, FPLLL, Enumeration, EnumerationError, EvaluatorStrategy
from fpylll.tools.quality import basis_quality
from fpylll.algorithms.bkz2 import BKZReduction
from fpylll.util import gaussian_heuristic

FPLLL.set_precision(200)
import time

def cnorm_numfield(a):
    #computes the euclidean norm of the number field element a after the Minkowski embedding

    #TODO: describe the function - DONE
    K = a.parent().fraction_field()
    sigmas = K.embeddings(CC)

    return sum( [abs(s(a))^2 for s in sigmas] )^(1/2)

def short_lattice_vectors(B, nr_solutions=1, verbose=False):
    #Given lattice basis B in a form of integer matrix B returns nr_solutions shortest vectors found in the lattice
    #If verbose flag is True: outputs some advanced information
    #TODO: describe the function - DONE

    n, m = B.nrows(), B.ncols()

    Mint = IntegerMatrix.from_matrix(B)

    #BKZ
    GSO_M = GSO.Mat(Mint, float_type='mpfr')
    GSO_M.update_gso()
    then=time.perf_counter()

    flags = BKZ_FPYLLL.AUTO_ABORT|BKZ_FPYLLL.MAX_LOOPS
    then=time.perf_counter()
    for beta in range(4,min(Mint.nrows, Mint.ncols),2):
        par = BKZ_FPYLLL.Param(block_size=beta, flags=flags, max_loops=25)
        bkz = BKZReduction(GSO_M)
        DONE = bkz(par)


    dt=time.perf_counter()-then
    R = GSO_M.get_r(0, 0)

    if verbose:
        print('BKZ counted in',dt, 'sec,', ' gh:', log(gaussian_heuristic([GSO_M.get_r(i,i) for i in range(n)])), 'true len:', log(R))

    then = time.perf_counter()
    enum = Enumeration(GSO_M, strategy=EvaluatorStrategy.BEST_N_SOLUTIONS, nr_solutions=nr_solutions)
    res = enum.enumerate( 0, n, R, 0   )
    if verbose:
        print('Enumeration done in', time.perf_counter()-then)

    return [Mint.multiply_left([round(t) for t in v[1]]) for v in res]#[vector([round(t) for t in v[1]])*Mint for v in res]


def test_field(field_conductor, p=3, p_max=10, verbose=False):

    #field_conductor: conductor of number field we decompose ideals over
    #p: number such that we start experiments from the next_prime(p-1)
    #p_max: primes we do experiments up to
    #vect_num: number of shortest vectors to check for a fixed ideal

    instances = []
    K.<z> = CyclotomicField(field_conductor)

    if verbose:
        print("Field degree: ", K.degree())
        print("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -")

    tries = 0
    succ  = 0

    p=p-1  #we start from the next_prime(p-1)

    while p<=p_max:
        p = next_prime(p)

        print('Counting for prime:', p)

        if verbose:
          print("Ideal (p) factors as:", factor( Ideal(K(p)) ))
          print('- - -')

        F = [l[0] for l in factor( Ideal(K(p)) )]

        for I in F:
            tries += 1
            if verbose:
                print(I)

            q = I.gen(1)

            M= [
                list(tmp) for tmp in I.basis()
            ]   #Z basis of the Ideal

            V = short_lattice_vectors(matrix(ZZ,M), 1)   #RETURN SHORT VECTOR COORDS

            v = [ZZ(tmp) for tmp in V[0]]

            j = K(list( vector(v)))  #TODO: rewrite short_lattice_vectors so it already returns v*B - DONE

            if verbose:
                print('j=',j)
            J = Ideal(j)
            flag = (J==I)   #flag showing if we found any of the ideal gens

            if verbose:
                if flag:
                    print('Ideal is generated by its shortest element:',end=' ')
                else:
                    print('Ideal not generated by any of its', len(V), 'shortest vectors')
            if verbose:
                print(flag,', N(I)=', norm(I), 'N(J)=', norm(J))
                print('|j|=', cnorm_numfield(j),'|p|=',p,'|q|=', cnorm_numfield(q))
                print()
            if not flag:
                succ += 1
                instances.append([(p,q), j if flag else 'No generator found!'])


    print(succ, 'succsesfull examples out of', tries,': ', (100*succ/tries).n(),'%')
    return(instances)


n = 2^6
res = test_field(n, 20, 10)
